#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include "stack.h"
#include "evaluation.h"

static void err(void) {
    puts("Error in expression.");
    exit(1);
}

/*
    // Usage Example

int main(int argc, char const *argv[]) {
    char *infix = strdup(argv[1]);
    size_t n = strlen(infix) * 3;
    char *postfix = malloc(n * sizeof(char));
    infixToPostfix(infix, postfix, n);
    free(infix);
    printf("Infix: %s\nPostfix: %s\nValue: %.3lf\n", argv[1], postfix, evaluatePostfix(postfix));
    return 0;
}

*/

static inline char *append(char *dest, char c, size_t *n) {
    if (!*n) {
        puts("Not enough memory.");
        exit(2);
    }
    *dest = c;
    (*n)--;
    return dest+1; // for chaining
}

double evaluatePostfix(const char *postfix) {
    // assuming valid, space-delimited postfix; as generated by infixToPostfix
    Stack *numbers = stack_initialize(strlen(postfix)/2);
    double a, b;
    Object obj;
    char *new = strdup(postfix);

    // strtok will insert a null after every token, helps ascii to number conversion
    for (char *token = strtok(new, " "); token; token = strtok(0, " ")) {
        if (isdigit(*token) || (*token == '-' && isdigit(*(token+1)))) {
            obj.d = strtod(token, 0);
            push(numbers, obj);
        }
        else { // operator
            b = pop(numbers).d;
            a = pop(numbers).d;
            switch(*token) {
                case '+': obj.d = a + b; break;
                case '-': obj.d = a - b; break;
                case '/': obj.d = a / b; break;
                case '*': obj.d = a * b; break;
                case '^': obj.d = pow(a, b); break;
            }
            push(numbers, obj);
        }
    }
    free(new);
    return obj.d; // the remaining number is the total value
}

void infixToPostfix(char *infix, char *postfix, size_t n) {
    const size_t len = strlen(infix);
    if (!len) return;

    // data
    Stack *operators = stack_initialize(len/2);
    // unsigned long is neat to use in Stack, as it aligns like a void * and increments as an integer
    Stack *level= stack_initialize(len); // parentheses group
    Object obj;

    // loop knobs
    unsigned int p_level = 0; //parentheses depth
    unsigned int c_level; // sea level ;)
    char priority = 0; // 'atomic' operation?
    char decimal = 0; // has radix point?
    char number = 1; // expect a number?

    for (char *token = infix;*token; ++token) {
        if (*token == '(') {
            if (!number) err();
            p_level++;
            if (priority) p_level += priority--; // save for later
            continue;
        } else if (*token == ')') {
            if (number) err();
            c_level = p_level--;
            if (!c_level) err();
            while ((unsigned int) pop(level).integer == c_level)
                postfix = append(append(postfix, *(char*) pop(operators).pointer, &n), ' ', &n);
            if (p_level > (unsigned int) top(level).integer) p_level -= ++priority; // symmetric!
            continue;
        }
        if (isspace(*token));
        else if (number) {
            if (!isdigit(*token) && !(*token == '-' && isdigit(*(token+1)))) err();
            do {
                if (decimal > 1) err();
                postfix = append(postfix, *token++, &n);
            } while (isdigit(*token) || (*token == '.' && ++decimal));
            decimal = 0;
            postfix = append(postfix, ' ', &n);
            token--;
            if (priority) {
                postfix = append(append(postfix, *(char*) pop(operators).pointer, &n), ' ', &n);
                priority = 0;
                pop(level);
            }
            number = 0;
        } else if (*token == '*' || *token == '/' || *token == '+' || *token == '-' || *token == '^') {
            obj.pointer = top(operators).pointer;
            // put 'atomic' brackets around * and / and exponents
            if (*token != '+' && *token != '-')
                priority = 1;
            else if (obj.pointer && *(char*) obj.pointer == '-') // to satisfy left-associativity
                postfix = append(append(postfix, *(char*) pop(operators).pointer, &n), ' ', &n);
            obj.pointer = token;
            push(operators, obj);
            obj.integer = p_level;
            push(level, obj);
            number = 1;
        } else err(); // garbage
    }
    if (p_level) err();
    // spit everything
    while (!stack_isEmpty(operators)) postfix = append(append(postfix, *(char*) pop(operators).pointer, &n), ' ', &n);
    *(postfix-1) = 0;
}
